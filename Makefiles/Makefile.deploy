# ; -*- mode: makefile ;-*-
# vi: set ft=make :
IAMLIVE := true
JUMP_HOST := $(PROJECT)-asg-jump-host-$(ENVIRONMENT)
REGION := eu-west-2
TF_LOG := WARN
TF_PROVIDER := "~> 5.0"
TF_MODULES := modules

CLUSTER := $(PROJECT)-ecs-cluster-$(ENVIRONMENT)
SERVICE := $(PROJECT)-ecs-service-$(ENVIRONMENT)

_deploy.confirm.destroy:
	@echo "CAUTION - Are you certain? Confirm with 'destroy' [destroy/N] " && \
		read ans && [ $${ans:-N} = destroy ]
.PHONY: _deploy.confirm.destroy

_deploy.docs:
	for dir in infra services _reusable; do \
		docker compose run -T --rm \
			$(PROJECT).deploy \
			terraform-docs \
			markdown \
			--recursive \
			--recursive-path $$dir \
			--output-file README.md \
			/opt/tf/$(TF_MODULES); \
	done
.PHONY: _deploy.docs

_deploy.ensure.cache:
	@mkdir -p $(HOME)/.terraform.d/plugin-cache
.PHONY: _deploy.ensure.cache

_deploy.fmt:
	docker compose run -T --rm \
		$(PROJECT).deploy \
		terraform fmt -diff -write
.PHONY: _deploy.fmt

_deploy.hclfmt:
	docker compose run -T --rm \
		$(PROJECT).deploy \
		terragrunt hclfmt -diff -write
.PHONY: _deploy.hclfmt

_deploy.format: _deploy.fmt _deploy.hclfmt
.PHONY: _deploy.format

_deploy.tfsec:
	docker compose run -T --rm \
		$(PROJECT).deploy \
		tfsec .
.PHONY: _deploy.tfsec

_deploy.update.message:
	@echo "You must call 'make deploy.init.update' \
		to install the new dependencies."
.PHONY: _deploy.update.message

_deploy.update.module:
ifndef args
	$(error Supply a module version and module name pair. \
		Usage: make _deploy.update.module \
		args='3.15.1 terraform-aws-modules/s3-bucket/aws')
else
	docker compose run -T --rm \
		$(PROJECT).deploy \
		tfupdate module -r --version $(args) modules
endif
	@$(MAKE) _deploy.update.message
.PHONY: _deploy.update.module

_deploy.update.provider:
	docker compose run -T --rm \
		$(PROJECT).deploy \
		tfupdate provider aws modules -r
	@$(MAKE) _deploy.update.message
.PHONY: _deploy.update.provider

_deploy.validate:
	docker compose run -T --rm \
		-e TF_DISABLE_INIT=true \
		$(PROJECT).deploy \
		terragrunt run-all validate \
		--terragrunt-working-dir environments/$(ENVIRONMENT) \
		--terragrunt-log-level $(TF_LOG)
.PHONY: _deploy.validate

### PUBLIC INTERFACE ###
deploy.apply:
ifndef module
	$(error Supply module for operation. \
		Usage: make deploy.apply module=ecs)
else
	docker compose run --rm \
		-e IAMLIVE=$(IAMLIVE) \
		$(PROJECT).deploy \
		terragrunt apply \
		--terragrunt-working-dir environments/$(ENVIRONMENT)/$(REGION)/$(module) \
		--terragrunt-log-level $(TF_LOG)
endif
.PHONY: deploy.apply

deploy.destroy: _deploy.confirm.destroy
ifndef module
	$(error Supply module for operation. \
		Usage: make deploy.destroy module=ecs)
else
	docker compose run --rm \
		$(PROJECT).deploy \
		terragrunt destroy \
		--terragrunt-working-dir environments/$(ENVIRONMENT)/$(REGION)/$(module) \
		--terragrunt-ignore-external-dependencies \
		--terragrunt-log-level $(TF_LOG) \
		--terragrunt-non-interactive
endif
.PHONY: deploy.destroy

deploy.ecs:
	docker compose run --rm \
		$(PROJECT).deploy \
		ecs deploy $(CLUSTER) $(SERVICE) \
		--timeout -1
.PHONY: deploy.ecs

deploy.graph:
	docker compose run -T --rm \
		$(PROJECT).deploy \
		terragrunt graph-dependencies \
		--terragrunt-working-dir environments/$(ENVIRONMENT) \
		--terragrunt-log-level $(TF_LOG)
.PHONY: deploy.graph

deploy.init: _deploy.ensure.cache
ifndef module
	$(error Supply module for operation. \
		Usage: make deploy.init module=vpc)
else
	docker compose run --rm \
		-e AWS_PROFILE=$(AWS_PROFILE) \
		$(PROJECT).deploy \
		terragrunt init \
		--terragrunt-working-dir environments/$(ENVIRONMENT)/$(REGION)/$(module) \
		--terragrunt-log-level $(TF_LOG)
endif
.PHONY: deploy.init

deploy.init.upgrade: _deploy.ensure.cache
ifndef module
	$(error Supply module for operation. \
		Usage: make deploy.init.upgrade module=vpc)
else
	docker compose run --rm \
		-e AWS_PROFILE=$(AWS_PROFILE) \
		$(PROJECT).deploy \
		terragrunt init -upgrade \
		--terragrunt-working-dir environments/$(ENVIRONMENT)/$(REGION)/$(module) \
		--terragrunt-log-level $(TF_LOG)
endif
.PHONY: deploy.init.upgrade

deploy.lint: _deploy.format _deploy.validate \
	_deploy.docs _deploy.tfsec
.PHONY: deploy.lint

deploy.plan:
ifndef module
	$(error Supply module for operation. \
		Usage: make deploy.plan module=ecs)
else
	docker compose run --rm \
		-e IAMLIVE=$(IAMLIVE) \
		$(PROJECT).deploy \
		terragrunt plan \
		--terragrunt-working-dir environments/$(ENVIRONMENT)/$(REGION)/$(module) \
		--terragrunt-log-level $(TF_LOG)
endif
.PHONY: deploy.plan

deploy.shell:
	docker compose run --rm \
		$(PROJECT).deploy \
		bash
.PHONY: deploy.shell

deploy.state.ls:
ifndef module
	$(error Supply module for operation. \
		Usage: make deploy.state.ls module=ecs)
else
	docker compose run --rm \
		$(PROJECT).deploy \
		terragrunt state list \
		--terragrunt-working-dir environments/$(ENVIRONMENT)/$(REGION)/$(module) \
		--terragrunt-log-level $(TF_LOG)
endif
.PHONY: deploy.state.ls

deploy.state.rm:
ifndef resource
	$(error Supply exact state resources to delete. \
		Usage: make deploy.state.rm \
		resource='aws_ecs_task_definition.example' \
		module=ecs)
else
	docker compose run --rm \
		$(PROJECT).deploy \
		terragrunt state rm \
		$(resource) \
		--terragrunt-working-dir environments/$(ENVIRONMENT)/$(REGION)/$(module) \
		--terragrunt-log-level $(TF_LOG)
endif
.PHONY: deploy.state.rm

deploy.ssh:
	$(CONFIG)/scripts/aws.ec2.ssh.sh \
		--jump_host "$(JUMP_HOST)" \
		--profile "$(AWS_PROFILE)" \
		--region "$(REGION)"
.PHONY: deploy.ssh

deploy.tunnel:
	$(CONFIG)/scripts/aws.ec2.tunnel.sh \
		--jump_host "$(JUMP_HOST)" \
		--profile "$(AWS_PROFILE)" \
		--region "$(REGION)" \
		--host "$(host)" \
		--host_bind "$(host_bind)" \
		--local_bind "$(local_bind)"
.PHONY: deploy.tunnel

deploy.update: _deploy.update.provider _deploy.update.module
.PHONY: deploy.update

deploy.help:
	@echo "  deploy.apply           provision a single module"
	@echo "  deploy.ecs             update the ecs service/task"
	@echo "  deploy.destroy         delete a single module"
	@echo "  deploy.init            initialize a single resource module"
	@echo "  deploy.init.upgrade    re-init/upgrade terraform providers for a module"
	@echo "  deploy.lint            invoke all terraform linters"
	@echo "  deploy.plan            generate a provisioning scheme for a single terraform module"
	@echo "  deploy.state.ls        detail the resources in the state for a module"
	@echo "  deploy.state.rm        do some surgery on the state for a module"
	@echo "  deploy.shell           shell into the deploy container"
	@echo "  deploy.ssh             open a secure shell to a deploy environment"
	@echo "  deploy.tunnel          forward ports via a secure tunnel into a deploy environment"
	@echo "  deploy.update          update all terraform provider and third-party module versions"
	@echo ""
.PHONY: deploy.help
