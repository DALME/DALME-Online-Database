"""Migrate auth data."""

from django_tenants.utils import tenant_context
from wagtail.users.models import UserProfile

from django.contrib.auth.models import Group
from django.db import connection, transaction

from oauth.models import GroupProperties, User
from tenants.models import Tenant

from .base import BaseStage

EXPECTED_GROUP_COUNT = 2
EXPECTED_PERMISSION_COUNT = 531


class Stage(BaseStage):
    """Data migration for auth data."""

    name = '01 Auth Migration'

    @transaction.atomic
    def apply(self):
        """Execute the stage."""
        self.migrate_users()
        self.migrate_groups()
        self.migrate_user_groups_relation()
        self.assert_user_user_permissions_invariant()
        self.scope_dalme_groups()
        self.update_global_ph_group()
        self.scope_dalme_members()
        self.scope_global_ph_members()
        self.ensure_user_profile()

    @transaction.atomic
    def migrate_users(self):
        """Copy user data."""
        if User.objects.count() == 0:
            with connection.cursor() as cursor:
                self.logger.info('Migrating users')
                profiles = cursor.execute('SELECT id, full_name, user_id FROM restore.core_profile;')
                profiles = {i['user_id']: i for i in self.map_rows(cursor)}
                users = cursor.execute('SELECT * FROM restore.auth_user;')
                users = self.map_rows(cursor)
                for user in users:
                    user['full_name'] = profiles.get(user['id'], {}).get('full_name', None)
                    User.objects.create(**user)
                self.logger.info('Created %s User instances', User.objects.count())
        else:
            self.logger.warning('User data already exists')

    @transaction.atomic
    def migrate_groups(self):
        """Copy group data."""
        if Group.objects.count() == EXPECTED_GROUP_COUNT:
            with connection.cursor() as cursor:
                self.logger.info('Migrating groups')
                cursor.execute('DELETE FROM public.auth_group;')
                groups = cursor.execute('SELECT * FROM restore.auth_group;')
                groups = self.map_rows(cursor)
                group_objs = [Group(**row) for row in groups]
                Group.objects.bulk_create(group_objs)
                self.logger.info('Created %s Group instances', Group.objects.count())

                self.logger.info('Migrating group properties')
                group_properties = cursor.execute(
                    'SELECT id, type AS group_type, description, group_id FROM restore.core_groupproperties;'
                )
                group_properties = self.map_rows(cursor)
                group_property_objs = [GroupProperties(**row) for row in group_properties]
                GroupProperties.objects.bulk_create(group_property_objs)
                self.logger.info('Created %s GroupProperties instances', GroupProperties.objects.count())
        else:
            self.logger.warning('Group data already exists')

    @transaction.atomic
    def migrate_user_groups_relation(self):
        """Preserve user group membership."""
        with connection.cursor() as cursor:
            self.logger.info('Migrating user groups relation')
            cursor.execute(
                'INSERT INTO public.domain_user_groups SELECT * FROM restore.auth_user_groups ON CONFLICT (id) DO NOTHING;'
            )

    # NOTE: Omitting permissions, it's complex, they are autogenerated and
    # mapped to content types by Django which are also autogenerated, so
    # trying to bring over old ones is a real headache.

    # NOTE: Similarly for the auth_group_permissions, another headache until we
    # can find an effective way to find the equivalent permissions between old
    # and new.

    @transaction.atomic
    def assert_user_user_permissions_invariant(self):
        """Verify there is no user user permissions data to migrate."""
        with connection.cursor() as cursor:
            assert len(cursor.execute('SELECT * from restore.auth_user_user_permissions;').fetchall()) == 0

    @transaction.atomic
    def scope_dalme_groups(self):
        """Scope Group Properties to tenants."""
        self.logger.info('Scoping DALME auth groups')
        ignore = {
            'DAM Editors',
            'DAM Users',
            'Developers',
            'Super Administrators',
            'Administrators',
            'Pharmacopeias',
            'KB Users',
            'Web Users',
            'Web Editors',
            'Editors',
        }
        dalme = Tenant.objects.get(name='DALME')
        for obj in GroupProperties.objects.all():
            if obj.group.name not in ignore and obj.tenant != dalme:
                obj.tenant = dalme
                obj.save()

    @transaction.atomic
    def update_global_ph_group(self):
        """Update legacy Team Pharmacopeia group data."""
        self.logger.info('Renaming and scoping the existing Pharmacopeias auth group')
        name = 'Pharmacopeias'
        try:
            group = Group.objects.get(name='Team Pharmacopeia')
        except Group.DoesNotExist:
            pass
        else:
            group.name = name
            group.save()
            group.properties.tenant = Tenant.objects.get(name=name)
            group.properties.save()

    @transaction.atomic
    def scope_dalme_members(self):
        """Register existing DALME users with the DALME tenant."""
        self.logger.info('Scoping users to the DALME tenant')
        additional = [5]  # user ids to include individually
        dalme = Tenant.objects.get(name='DALME')
        non_members = User.objects.filter(groups__name='Pharmacopeias')
        members = User.objects.exclude(id__in=non_members.values_list('id', flat=True))
        dalme.members.add(*members)
        # add additional
        members = User.objects.filter(id__in=additional)
        dalme.members.add(*members)

    @transaction.atomic
    def scope_global_ph_members(self):
        """Register existing Global Pharmacopeias users with the Pharmacopeias tenant."""
        self.logger.info('Scoping users to the Pharmacopeias tenant')
        name = 'Pharmacopeias'
        global_ph = Tenant.objects.get(name=name)
        members = User.objects.filter(groups__name=name)
        global_ph.members.add(*members)

    @transaction.atomic
    def ensure_user_profile(self):
        """Make sure all users have a wagtail profile record."""
        self.logger.info('Ensuring all users have a user profile')
        p_count = 0
        for user in User.objects.all():
            if not user.profile:
                with tenant_context(user.tenant_set.first()):
                    UserProfile.objects.create(user=user)
                    p_count += 1
        if p_count:
            self.logger.debug('Linked %s profile instances', p_count)
        else:
            self.logger.info('All users have a user profile.')
