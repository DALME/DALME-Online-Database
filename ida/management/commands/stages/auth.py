"""Migrate auth data."""

from django.contrib.auth.models import Group
from django.db import connection, transaction

from ida.models import GroupProperties, Profile, Tenant, User

from .base import BaseStage

EXPECTED_GROUP_COUNT = 2
EXPECTED_PERMISSION_COUNT = 531


class Stage(BaseStage):
    """Data migration for auth data."""

    name = '01 Auth Migration'

    @transaction.atomic
    def apply(self):
        """Execute the stage."""
        self.migrate_users()
        self.migrate_groups()
        self.migrate_user_groups_relation()
        self.assert_user_user_permissions_invariant()
        self.scope_dalme_groups()
        self.update_global_ph_group()
        self.scope_dalme_members()
        self.scope_global_ph_members()
        self.ensure_user_profile()

    @transaction.atomic
    def migrate_users(self):
        """Copy user data."""
        if User.objects.count() == 0:
            with connection.cursor() as cursor:
                self.logger.info('Migrating users')
                users = cursor.execute('SELECT * FROM restore.auth_user;')
                users = self.map_rows(cursor)
                user_objs = [User(**row) for row in users]
                User.objects.bulk_create(user_objs)
                self.logger.info('Created %s User instances', User.objects.count())

                self.logger.info('Migrating user profiles')
                profiles = cursor.execute('SELECT id, full_name, user_id FROM restore.core_profile;')
                profiles = self.map_rows(cursor)
                profile_objs = [Profile(**row) for row in profiles]
                Profile.objects.bulk_create(profile_objs)
                self.logger.info('Created %s Profile instances', Profile.objects.count())
        else:
            self.logger.info('User data already exists')

    @transaction.atomic
    def migrate_groups(self):
        """Copy group data."""
        if Group.objects.count() == EXPECTED_GROUP_COUNT:
            with connection.cursor() as cursor:
                self.logger.info('Migrating groups')
                cursor.execute('DELETE FROM public.auth_group;')
                groups = cursor.execute('SELECT * FROM restore.auth_group;')
                groups = self.map_rows(cursor)
                group_objs = [Group(**row) for row in groups]
                Group.objects.bulk_create(group_objs)
                self.logger.info('Created %s Group instances', Group.objects.count())

                self.logger.info('Migrating group properties')
                group_properties = cursor.execute(
                    'SELECT id, type AS group_type, description, group_id FROM restore.core_groupproperties;'
                )
                group_properties = self.map_rows(cursor)
                group_property_objs = [GroupProperties(**row) for row in group_properties]
                GroupProperties.objects.bulk_create(group_property_objs)
                self.logger.info('Created %s GroupProperties instances', GroupProperties.objects.count())
        else:
            self.logger.info('Group data already exists')

    @transaction.atomic
    def migrate_user_groups_relation(self):
        """Preserve user group membership."""
        with connection.cursor() as cursor:
            self.logger.info('Migrating user groups relation')
            cursor.execute(
                'INSERT INTO public.ida_user_groups SELECT * FROM restore.auth_user_groups ON CONFLICT (id) DO NOTHING;'
            )

    # NOTE: Omitting permissions, it's complex, they are autogenerated and
    # mapped to content types by Django which are also autogenerated, so
    # trying to bring over old ones is a real headache.

    # NOTE: Similarly for the auth_group_permissions, another headache until we
    # can find an effective way to find the equivalent permissions between old
    # and new.

    @transaction.atomic
    def assert_user_user_permissions_invariant(self):
        """Verify there is no user user permissions data to migrate."""
        with connection.cursor() as cursor:
            assert len(cursor.execute('SELECT * from restore.auth_user_user_permissions;').fetchall()) == 0

    @transaction.atomic
    def scope_dalme_groups(self):
        """Scope Group Properties to tenants."""
        self.logger.info('Scoping DALME auth groups')
        ignore = {
            'DAM Editors',
            'DAM Users',
            'Developers' 'Super Administrators',
            'Global Pharmacopeias',
            'Team Pharmacopeia',
        }
        dalme = Tenant.objects.get(name='DALME')
        for obj in GroupProperties.objects.all():
            if obj.group.name not in ignore and obj.tenant != dalme:
                obj.tenant = dalme
                obj.save()

    @transaction.atomic
    def update_global_ph_group(self):
        """Update legacy Team Pharmacopeia group data."""
        self.logger.info('Renaming and scoping the existing Global Pharmacopeias auth group')
        name = 'Global Pharmacopeias'
        try:
            group = Group.objects.get(name='Team Pharmacopeia')
        except Group.DoesNotExist:
            pass
        else:
            group.name = name
            group.save()
            group.properties.tenant = Tenant.objects.get(name=name)
            group.properties.save()

    @transaction.atomic
    def scope_dalme_members(self):
        """Register existing DALME users with the DALME tenant."""
        self.logger.info('Scoping users to the DALME tenant')
        dalme = Tenant.objects.get(name='DALME')
        non_members = User.objects.filter(groups__name='Global Pharmacopeias')
        members = User.objects.exclude(id__in=non_members.values_list('id', flat=True))
        dalme.members.add(*members)

    @transaction.atomic
    def scope_global_ph_members(self):
        """Register existing Global Pharmacopeias users with the Global Pharmacopeias tenant."""
        self.logger.info('Scoping users to the Global Pharmacopeias tenant')
        name = 'Global Pharmacopeias'
        global_ph = Tenant.objects.get(name=name)
        members = User.objects.filter(groups__name=name)
        global_ph.members.add(*members)

    @transaction.atomic
    def ensure_user_profile(self):
        """Make sure all users have a profile record."""
        self.logger.info('Ensuring all users have a user profile')
        objs = User.objects.filter(profile__isnull=True)
        for obj in objs:
            Profile.objects.create(user=obj, full_name=f'{obj.first_name} {obj.last_name}')
        self.logger.info('Linked %s Profile instances', len(objs))
