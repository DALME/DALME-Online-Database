"""Create entries necessary for new data schemas."""

import os

from django_tenants.utils import schema_context
from wagtail.log_actions import log

from django.apps import apps
from django.db import connection, transaction

from ida.models import (
    Project,
    Tenant,
    ZoteroCollection,
)

from .base import BaseStage


class Stage(BaseStage):
    """Fixes after finishing all data migrations."""

    name = '11 Content fixes'

    @transaction.atomic
    def apply(self):
        """Execute the stage."""
        self.adjust_id_columns()
        self.create_project_and_library_entries()
        self.update_footnote_state()
        self.fix_biblio_page()
        self.replace_about_people()
        self.fix_media_paths()
        self.process_images()

    @transaction.atomic
    def adjust_id_columns(self):
        """Adjust autogenerated id sequences."""
        app_labels = [
            ('dalme', 'taggit'),
            ('dalme', 'wagtailadmin'),
            ('dalme', 'wagtailcore'),
            ('dalme', 'wagtaildocs'),
            ('dalme', 'wagtailembeds'),
            ('dalme', 'wagtailforms'),
            ('dalme', 'wagtailimages'),
            ('dalme', 'wagtailredirects'),
            ('public', 'wagtailusers'),
            ('dalme', 'public'),
            ('dalme', 'publicimages'),
        ]

        for schema, app in app_labels:
            self.logger.info('Adjusting autogenerated id sequences for "%s" models', app)
            app_config = apps.get_app_config(app)
            if app_config.models_module is not None:
                for model in app_config.get_models():
                    model_name = model.__name__.lower()
                    qualified_name = f'{app}_{model_name}'
                    self.logger.info('Processing "%s"', qualified_name)

                    with connection.cursor() as cursor:
                        cursor.execute(f'SELECT * FROM {schema}.{qualified_name};')
                        rows = self.map_rows(cursor)
                        id_list = [int(row['id']) for row in rows if row.get('id')]
                        if id_list:
                            new_seq_start = max(id_list) + 1
                            cursor.execute(
                                f'ALTER TABLE {schema}.{qualified_name} ALTER COLUMN id RESTART WITH {new_seq_start};'
                            )

    @transaction.atomic
    def create_project_and_library_entries(self):
        # DALME
        self.logger.info('Creating project and library entries for DALME')
        collections = [
            {
                'id': 'A4QHN348',
                'label': 'Editions',
                'has_biblio_sources': True,
            },
            {
                'id': 'BKW2PVCM',
                'label': 'Glossaries and dictionaries',
                'has_biblio_sources': False,
            },
            {
                'id': 'QM9AZNT3',
                'label': 'Methodology',
                'has_biblio_sources': False,
            },
            {
                'id': 'SLIT6LID',
                'label': 'Studies',
                'has_biblio_sources': False,
            },
            {
                'id': 'FRLVXUWL',
                'label': 'Other resources',
                'has_biblio_sources': False,
            },
        ]
        tenant = Tenant.objects.get(name='DALME')
        new_project = Project.objects.create(
            name='DALME',
            description='The Documentary Archaeology of Late Medieval Europe',
            zotero_library_id=int(os.environ['ZOTERO_LIBRARY_ID']),
            zotero_api_key=os.environ['ZOTERO_API_KEY'],
            tenant=tenant,
        )

        for collection in collections:
            collection.update(project=new_project)
            z_col = ZoteroCollection.objects.create(**collection)

            with schema_context('dalme'):
                log(instance=z_col, action='wagtail.create')

        # GP
        self.logger.info('Creating project and library entries for GP')
        tenant = Tenant.objects.get(name='Pharmacopeias')
        new_project = Project.objects.create(
            name='Pharmacopeias',
            description='Pharmacopeias',
            zotero_library_id=int(os.environ['ZOTERO_LIBRARY_ID_GP']),
            zotero_api_key=os.environ['ZOTERO_API_KEY_GP'],
            tenant=tenant,
        )

    # @transaction.atomic
    # def content_conversions(self):
    #     """Convert content between old and new formats (footnotes, references, people/team members)."""
    #     targets = {
    #         'public': [
    #             'collection',
    #             'collections',
    #             'essay',
    #             'featuredinventory',
    #             'featuredobject',
    #             'features',
    #             'flat',
    #         ],
    #         'wagtailcore': ['revision'],
    #     }

    #     self.logger.info('Performing content entity conversions...')
    #     for app_label, models in targets.items():
    #         for model_name in models:
    #             qualified_name = f'{app_label}_{model_name}'
    #             self.logger.info('Processing "%s"', qualified_name)
    #             with schema_context('dalme'):
    #                 model = apps.get_model(app_label=app_label, model_name=model_name)
    #                 target_fields = self.get_fields_by_type(model, ['JSONField', 'RichTextField'], as_map=True)
    #                 self.logger.info(
    #                     'Targetting: %s JSONField | %s Other',
    #                     len([f for f in target_fields if f[1] == 'JSONField']),
    #                     len([f for f in target_fields if f[1] != 'JSONField']),
    #                 )
    #                 for instance in model.objects.all():
    #                     updated_fields = []
    #                     for field_name, field_type in target_fields:
    #                         field_value = getattr(instance, field_name, None)
    #                         if field_value:
    #                             updated_fields.append(field_name)
    #                             setattr(
    #                                 instance, field_name, self.process_content_field(field_value, field_type, instance)
    #                             )

    #                     instance.save(update_fields=updated_fields)

    @transaction.atomic
    def update_footnote_state(self):
        """Update footnote state fields for pages."""
        targets = [
            'collection',
            'collections',
            'essay',
            'featuredinventory',
            'featuredobject',
            'features',
            'flat',
        ]

        self.logger.info('Updating footnote state fields...')
        for model_name in targets:
            qualified_name = f'public_{model_name}'
            self.logger.info('Processing "%s"', qualified_name)
            with schema_context('dalme'):
                model = apps.get_model(app_label='public', model_name=model_name)
                for instance in model.objects.all():
                    raw_content = str(instance.body.raw_data)
                    instance.has_footnotes = 'data-footnote=' in raw_content
                    instance.has_placemarker = 'footnotes_placemarker' in raw_content
                    instance.save(update_fields=['has_footnotes', 'has_placemarker'])

    @transaction.atomic
    def fix_biblio_page(self):
        """Fix collection block references in bibliography page."""
        self.logger.info('Fix collection block references in bibliography page')
        with schema_context('dalme'):
            from public.models import Bibliography

            biblio_page = Bibliography.objects.first()
            body = biblio_page.body.get_prep_value()
            for block in body:
                if block.get('type') == 'bibliography':
                    block['value'] = block['value']['collection']

            biblio_page.body = body
            biblio_page.save(update_fields=['body'])

    @transaction.atomic
    def replace_about_people(self):
        """Replace the About > People page with one that uses the new Team extension."""
        people_page_data = {
            'title': 'People',
            'short_title': 'People',
            'header_image_id': 11,
            'slug': 'people',
            'show_in_menus': True,
            'body': [
                {'id': 'eac3c1b6-6724-42af-a039-afef0ca8b880', 'type': 'heading', 'value': 'Project Team'},
                {
                    'id': '83f8d736-839d-407b-82ed-90e7ae981ccf',
                    'type': 'team_list',
                    'value': {
                        'mode': 'members',
                        'role': '',
                        'order': 'name',
                        'members': ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
                    },
                },
                {'id': '61df150f-065e-4c33-b103-e5ae76991cc3', 'type': 'heading', 'value': 'Contributors'},
                {
                    'id': '447c0a2f-d127-4937-a72d-bb9644592883',
                    'type': 'team_list',
                    'value': {'mode': 'role', 'role': '3', 'order': 'name', 'members': []},
                },
                {'id': 'd91180b0-8a60-4c9b-8ed2-4b16fe840bec', 'type': 'heading', 'value': 'Advisory Board'},
                {
                    'id': 'c381034b-a89c-4df8-b578-40781dc24044',
                    'type': 'text',
                    'value': '<p data-block-key="khpxl">The members of the DALME board help convey news about the project to colleagues and students in the field and, in turn, bring potential contributors and resources to our attention.</p>',
                },
                {
                    'id': '89294881-07a3-4582-8a86-2733be10b447',
                    'type': 'team_list',
                    'value': {'mode': 'role', 'role': '4', 'order': 'name', 'members': []},
                },
            ],
        }

        self.logger.info('Replacing About > People page...')
        with schema_context('dalme'):
            from wagtail.models import Page

            from public.models import People

            # delete existing People page
            Page.objects.get(title='People').delete()

            # create new one
            about_page = Page.objects.get(title='About').specific
            people_page = about_page.add_child(instance=People(**people_page_data))
            people_page.save_revision().publish()

    @transaction.atomic
    def fix_media_paths(self):
        """Adjust paths to media files to include the tenant."""
        self.logger.info('Adjusting media file paths...')
        # we do this directly in SQL to avoid triggering any of the methods in the FileField
        tables = ['publicimages_baseimage', 'publicimages_customrendition', 'wagtaildocs_document']
        with connection.cursor() as cursor:
            for table in tables:
                cursor.execute(f"UPDATE dalme.{table} SET file = 'dalme/' || file;")

    @transaction.atomic
    def process_images(self):
        """Apply feature recognition to images and get rendition for people."""
        self.logger.info('Applying feature recognition to images and generating renditions...')
        with schema_context('dalme'):
            from wagtail.images import get_image_model

            Image = get_image_model()  # noqa: N806

            for image in Image.objects.all():
                try:
                    if not image.has_focal_point():
                        image.set_focal_point(image.get_suggested_focal_point())
                        image.save()
                        image.get_rendition('fill-100x100')
                except:  # noqa: E722
                    pass
