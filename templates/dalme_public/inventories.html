{% extends "dalme_public/layouts/__single_column.html" %}
{% load static %}

{% block title %}Inventories &mdash; {{ block.super }}{% endblock %}

{% block styles %}
  {{ block.super }}
  <link rel="stylesheet" href="https://unpkg.com/vue-select@latest/dist/vue-select.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/vue-slider-component@latest/theme/default.css">
{% endblock %}

{% block header_extra %}
  {% include "dalme_public/includes/_breadcrumbs.html" %}
{% endblock %}

{% block main_column %}
  <div id="app" class="app inventory-list">
    <nav>
      <ul class="u-flex">
        <li class="filter right" @click="toggleFilters" v-on-clickaway="hideFilters">
          <span>Filter</span>
          <i class="fa fa-sort" aria-hidden="true"></i>
        </li>
        <li class="search">
          <input
            type="search"
            placeholder="Search"
            v-model="search"
            :value="search"
          >
        </li>
        <div class="filter-panel" v-if="showFilters">
          <form method="get" class="filter-form u-flex">

            <div class="label">Corpus</div>
            <v-select
              :options="choices.corpusChoices"
              @input="setCorpus"
              v-model="corpus">
            </v-select>

            <div class="label">Collection</div>
            <v-select
              :options="choices.collectionChoices"
              @input="setCollection"
              v-model="collection">
            </v-select>

            <div class="label">Record Type</div>
            <v-select
              :options="choices.sourceTypeChoices"
              @input="setSourceType"
              v-model="sourceType">
            </v-select>

            <div class="label">Date</div>
            <vue-slider
              ref="slider"
              v-model="date"
              lazy="true"
              stop-propagation="true"
              :min="dateMin"
              :max="dateMax"
            >
            </vue-slider>

            <div class="label">Assets</div>
            <div class="asset u-flex">
              <input
                type="checkbox"
                id="imageCheckbox"
                @input="setHasImage"
                v-model="hasImage">
              <label for="checkbox">Image</label>
            </div>
            <div class="asset u-flex">
              <input
                type="checkbox"
                id="transcriptionCheckbox"
                @input="setHasTranscription"
                v-model="hasTranscription">
              <label for="checkbox">Transcription</label>
            </div>

          </form>
        </div>
      </ul>
    </nav>

    <section>
      <p v-if="spinner">Fetching sources...</p>
      <template v-else>
        <p v-if="noResults">No inventories found.</p>
        <div v-else class="u-grid inventories">
          <span class="heading">
            <strong @click="toggleNameOrder" >Name</strong>
          </span>
          <span class="heading">
            <strong @click="toggleSourceTypeOrder">Type</strong>
          </span>
          <span class="heading">
            <strong @click="toggleDateOrder">Date</strong>
          </span>
          <!-- Placeholder element to regulate the grid. -->
          <span class="heading"></span>

          <template v-for="(inventory, index) in inventories" :key="index">
            <span class="inventory-field">
              <a :href="inventoryUrl(inventory)">
                ${inventory.name}<span class="short-name"> ${inventory.short_name}</span>
              </a>
            </span>
            <span class="inventory-field">${inventory.record_type}</span>
            <span class="inventory-field">${inventory.date}</span>
            <span class="inventory-field icons">
              <i v-if="inventory.has_images" class="fas fa-pen-nib"></i>
              <i v-if="inventory.has_transcriptions" class="fas fa-camera"></i>
            </span>
          </template>
        </div>
      </template>
    </section>

    <div v-if="!spinner" class="pagination u-flex">
      <span class="step-links">
        <template v-if="previous">
          <i class="fas fa-angle-double-left step-first active" @click="handleFirstPage"></i>
          <i class="fas fa-angle-left active" @click="handlePreviousPage"></i>
        </template>
        <template v-else>
          <i class="fas fa-angle-double-left step-first inactive"></i>
          <i class="fas fa-angle-left inactive"></i>
        </template>

        <span class="current">${currentPageInfo}</span>

        <template v-if="next">
          <i class="fas fa-angle-right active" @click="handleNextPage"></i>
          <i class="fas fa-angle-double-right step-last active" @click="handleLastPage"></i>
        </template>
        <template v-else>
          <i class="fas fa-angle-right inactive"></i>
          <i class="fas fa-angle-double-right step-last inactive"></i>
        </template>
      </span>
    </div>

</div>

{% endblock %}

{% block js_foot %}
  {{ block.super }}
  <script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script>
  <script src="https://unpkg.com/vue-select@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/vue-clickaway@2.2.2/dist/vue-clickaway.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vue-slider-component@latest/dist/vue-slider-component.umd.min.js"></script>
  <script type="text/javascript" src="{% static 'js/lodash-debounce.js' %}"></script>
  <script>
    Vue.component('v-select', VueSelect.VueSelect);
    const app = new Vue({
      el: '#app',
      delimiters: ['${', '}'],
      created() {
        this.fetchData();
        this.fetchChoices();
      },
      components: {
        'vue-slider': window['vue-slider-component'],
      },
      directives: {
        onClickaway: window.VueClickaway.directive,
      },
      data: {
        fetching: false,
        inventories: null,
        next: null,
        previous: null,
        count: null,
        totalPages: null,
        currentPage: null,
        search: new URLSearchParams(window.location.search).get('name'),
        showFilters: false,
        corpus: null,
        collection: null,
        sourceType: null,
        date: [1200, 1500],
        hasImage: null,
        hasTranscription: null,
        dateOrder: null,
        sourceTypeOrder: null,
        dateOrder: null,
        choices: {},
      },
      watch: {
        search: debounce(function() {
          this.filterData('name', this.search)
        }, 250),
        date: debounce(function() {
          const [min, max] = this.date;
          if (min === this.dateMin && max === this.dateMax) {
            const params = this.setParam('date_range', null).toString();
            this.updateURL(params);
            this.fetchData();
          } else {
            this.filterData('date_range', this.date);
          }
        }, 250),
      },
      computed: {
        dateMin() {
          return 1200;
        },
        dateMax() {
          return 1500;
        },
        isFiltered() {
          return [
            this.corpus,
            this.collection,
            this.sourceType,
            this.date,
            this.hasImage,
            this.hasTranscription
          ].some(value => value);
        },
        endpoint() {
          return '/api/public/sources';
        },
        choicesEndpoint() {
          return '/api/public/choices';
        },
        spinner() {
          return (this.inventories === null) || this.fetching == true;
        },
        noResults() {
          return Array.isArray(this.inventories) && !this.inventories.length;
        },
        currentPageInfo() {
          return `Showing page ${this.currentPage} of ${this.totalPages}`;
        },
        url() {
          return location.protocol + '//' + location.host + location.pathname;
        },
        currentParams() {
          return new URLSearchParams(window.location.search);
        },
      },
      methods: {
        setCorpus() {
          const value = this.corpus ? this.corpus.id : null;
          this.filterData('corpus', value);
        },
        setCollection() {
          const value = this.collection ? this.collection.id : null;
          this.filterData('collection', value);
        },
        setSourceType() {
          const value = this.sourceType ? this.sourceType.id : null;
          this.filterData('source_type', value);
        },
        setHasImage() {
          this.filterData('has_image', !this.hasImage);
        },
        setHasTranscription() {
          this.filterData('has_transcription', !this.hasTranscription);
        },
        toggleNameOrder() {
          this.nameOrder = this.nameOrder
            ? this.nameOrder === 'name'
              ? this.nameOrder = '-name'
              : this.nameOrder = 'name'
            : this.nameOrder = '-name';
          this.filterData('order_by', this.nameOrder);
        },
        toggleSourceTypeOrder() {
          this.sourceTypeOrder = this.sourceTypeOrder
            ? this.sourceTypeOrder === 'source_type'
              ? this.sourceTypeOrder = '-source_type'
              : this.sourceTypeOrder = 'source_type'
            : this.sourceTypeOrder = '-source_type';
          this.filterData('order_by', this.sourceTypeOrder);
        },
        toggleDateOrder() {
          this.dateOrder = this.dateOrder
            ? this.dateOrder === 'date'
              ? this.dateOrder = '-date'
              : this.dateOrder = 'date'
            : this.dateOrder = '-date'
          this.filterData('order_by', this.dateOrder);
        },
        destructureParams() {
          let params = {};
          this.currentParams.forEach((value, key) => {
            const camelized = key.replace(/(_\w)/g, k => k[1].toUpperCase());
            if (['collection', 'corpus', 'source_type'].includes(key)) {
              value = this.choices[`${camelized}Choices`]
                .filter(item => {
                  return key === 'source_type'
                    ? item.id == value
                    : item.id === parseInt(value);
                });
            }
            return params[camelized] = typeof value === 'object' ? value[0] : value;
          });
          return params;
        },
        fetchChoices() {
          fetch(this.choicesEndpoint)
            .then(response => response.json())
            .then(data => {
              this.choices = data;
              const params = this.destructureParams();
              for (let [key, value] of Object.entries(params)) {
                this[key] = value;
              }
            });
        },
        fetchData(url = null) {
          this.fetching = true;
          fetch(url || `${this.endpoint}/?${this.currentParams.toString()}`)
            .then(response => response.json())
            .then(data => {
              this.inventories = data.results;
              this.next = data.next;
              this.previous = data.previous;
              this.count = data.count;
              this.totalPages = data.totalPages;
              this.currentPage = data.currentPage;
              this.fetching = false;
            });
        },
        setParam(key, value) {
          let params = this.currentParams;
          if (!value) {
            params.delete(key);
          } else {
            params.set(key, value);
          }
          return params;
        },
        updateURL(params) {
          const url = params ? `${this.url}?${params}` : this.url;
          window.history.pushState(null, null, url);
        },
        filterData(key, value) {
          const params = this.setParam(key, value).toString();
          this.fetchData(`${this.endpoint}/?${params}`);
          this.updateURL(params);
        },
        inventoryUrl(inventory) {
          return `${location.pathname}${inventory.id}`;
        },
        toggleFilters() {
          this.showFilters = !this.showFilters;
        },
        hideFilters(e) {
          if (!e.target.closest('.filter-panel')) {
            this.showFilters = false;
          }
        },
        handleFirstPage() {
          const params = this.setParam('page', 1).toString();
          this.fetchData(`${this.endpoint}/?${params}`);
          this.updateURL(params);
        },
        handlePreviousPage() {
          if (this.previous) {
            const params = this.setParam('page', this.previous).toString();
            this.fetchData(`${this.endpoint}/?${params}`);
            this.updateURL(params);
          }
        },
        handleNextPage() {
          if (this.next) {
            const params = this.setParam('page', this.next).toString();
            this.fetchData(`${this.endpoint}/?${params}`);
            this.updateURL(params);
          }
        },
        handleLastPage() {
          const params = this.setParam('page', this.totalPages).toString();
          this.fetchData(`${this.endpoint}/?${params}`);
          this.updateURL(params);
        },
      },
    });
  </script>
{% endblock %}
